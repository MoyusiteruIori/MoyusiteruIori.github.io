<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>用 C/C++ 写一个自己的 Redis | 程序员和他的雀庄</title><meta name="keywords" content="Build your own, C/C++, Redis"><meta name="author" content="伊织Iori"><meta name="copyright" content="伊织Iori"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="从 0 用 C&#x2F;C++ 自己写一个 Redis">
<meta property="og:type" content="article">
<meta property="og:title" content="用 C&#x2F;C++ 写一个自己的 Redis">
<meta property="og:url" content="http://example.com/2023/07/23/redis-from-scratch/index.html">
<meta property="og:site_name" content="程序员和他的雀庄">
<meta property="og:description" content="从 0 用 C&#x2F;C++ 自己写一个 Redis">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2023/07/23/redis-from-scratch/cover.png">
<meta property="article:published_time" content="2023-07-23T13:27:36.000Z">
<meta property="article:modified_time" content="2023-07-28T15:31:01.249Z">
<meta property="article:author" content="伊织Iori">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="C">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/07/23/redis-from-scratch/cover.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/07/23/redis-from-scratch/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '用 C/C++ 写一个自己的 Redis',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-28 23:31:01'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/2023/07/23/redis-from-scratch/cover.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">程序员和他的雀庄</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">用 C/C++ 写一个自己的 Redis</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-23T13:27:36.000Z" title="发表于 2023-07-23 21:27:36">2023-07-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-28T15:31:01.249Z" title="更新于 2023-07-28 23:31:01">2023-07-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C-C/">C/C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="用 C/C++ 写一个自己的 Redis"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>原文链接：<a target="_blank" rel="noopener" href="https://build-your-own.org/redis/">https://build-your-own.org/redis/</a><br>翻译：伊织</p>
<p><strong>从 0 开始写代码来学习网络编程和数据结构</strong></p>
<p>作者：James Smith</p>
<ul>
<li><strong>为什么要写 Redis ？</strong> 因为写一个 Redis 所需要的知识比一般的应用层开发来得更广也更深，这是一种很好的培养能力的办法。（主要是在网络编程和数据结构方面）</li>
<li><strong>为什么从 0 开始写？</strong> Richard Feynman 有句名言：“只要我不能创造的，我就还不理解”。人类的理解充满了漏洞，即“我不知道我不知道的事情”。从 0 开始编程能够确保你的理解比较完整。</li>
<li><strong>为什么要写 C ？</strong> 因为 C 语言被广泛应用在系统编程和基础软件中，所以通过直接的 C 代码来学习 C 是如何在实际项目中应用的，而且也不需要 C&#x2F;C++ 的预备知识。</li>
<li><strong>为什么是以一本书的形式？</strong> Redis 非常复杂，花费了人们很多精力，初学者直接学习会非常困难。这本书把核心的概念拆开，以便读者一步步学习。</li>
</ul>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="这本书是写什么的？"><a href="#这本书是写什么的？" class="headerlink" title="这本书是写什么的？"></a>这本书是写什么的？</h2><p>这本书一步一步地演示了一个 Redis-like 的服务器的简单实现，旨在成为一个 C 语言网络编程和数据结构的实现与应用的实用指南&#x2F;教程。</p>
<h2 id="从这本书能学到什么？"><a href="#从这本书能学到什么？" class="headerlink" title="从这本书能学到什么？"></a>从这本书能学到什么？</h2><p>Redis 可以说是现代计算机世界的<em>一块基石</em>，经受住了时间的考验。编写这样一个项目所需的知识比通常的应用层开发来得更广也更深。学习这样一个项目是程序员自我提高的一种非常好的办法。<br>Redis 是一个非常好的学习目标，因为它涵盖了软件工程的两个重要主题：网络编程和数据结构。</p>
<ul>
<li>你能找到很多 socket API 和高级程序库的教程，但是网络编程远远不止调包这么简单。很重要的一点是要理解一些核心概念，比如事件循环（event loop）、协议（protocol）、定时器（timer）等等，这本书里都会包含。如果你不理解这些核心概念，那你就算只当调包侠，也常常会写出 fatal error。</li>
<li>很多人从书上学会了基本数据结构，但其实要继续学的东西还多着呢。真实项目中的数据结构往往有一些教科书上不会提及的实践考量。学习一个非玩具的正经项目中是怎么使用数据结构的，这会是写 Redis 带给你的一段独特体验。</li>
</ul>
<p>正如大多数真实世界的项目一样，Redis 非常复杂，凝结了人们大量的努力，对于初学者来说直接学习会非常困难。因此这本书采取一种相反的策略：<em>从零开始</em>自己写一个。</p>
<h2 id="为什么要从-0-开始？"><a href="#为什么要从-0-开始？" class="headerlink" title="为什么要从 0 开始？"></a>为什么要从 0 开始？</h2><p>原因有以下几点：</p>
<ul>
<li><strong>为了学得更快。</strong> 从 0 开始写一样东西的过程能够循序渐进的引入各个概念。从最小的东西开始，增量地添加功能，最后搞个大的出来。</li>
<li><strong>为了学得更深。</strong> 虽然有很多资料可以解释现在的东西都是怎么工作的，但你从阅读资料中获得的理解通常不如自己写一个来得深刻。只读不写的话就很容易记错，或者找不到重点。</li>
<li><strong>为了学得更多。</strong> “从 0 开始”强迫你去了解项目的各个方面，不会有你错过的知识！而且通常不是每个方面的知识你都提前有所了解的，你会在这个过程中发现一些“我不知道我不知道的东西”。</li>
</ul>
<p>一言以蔽之，就是 Richard Feynman 的名言：“只要我不能创造的，我就还不理解”。</p>
<h2 id="如何使用本书？"><a href="#如何使用本书？" class="headerlink" title="如何使用本书？"></a>如何使用本书？</h2><p>这本书之后的章节会是循序渐进一步一步的。每一步都基于上一步，增加一个新的概念。网站会提供完整的源代码，建议读者自行调试或者尝试自己编写。</p>
<p>作者会把代码写得尽可能直截了当。大多数是朴素的 C 语言，少部分涉及 C++ 特性。没学过 C 的话也别担心，你刚好可以自己用另一门语言来实现。</p>
<p>最后的成果会是一个迷你版的 Redis ，差不多就 1200 行代码。别看 1200 很少，其中包括了这本书覆盖的很多重要方面。</p>
<p>这本书中使用的技术和方法并不是和真实的 Redis 完全一致的，有一部分被刻意简化了，有一些更普适化。比较这些方法的不同点能让读者学到更多东西。</p>
<p>这本书的代码只能在 Linux 上跑，代码可以从这里下载：</p>
<p><a target="_blank" rel="noopener" href="https://build-your-own.org/redis/src.tgz">https://build-your-own.org/redis/src.tgz</a></p>
<p>书的内容和源代码可以在这里在线阅读：</p>
<p><a target="_blank" rel="noopener" href="https://build-your-own.org/">https://build-your-own.org</a></p>
<p>（注：本篇翻译中的代码是译者按照教程自己写的，和原文会略有出入，但大体上是一致的，译者的代码仓库：）</p>
<h1 id="Socket-简介"><a href="#Socket-简介" class="headerlink" title="Socket 简介"></a>Socket 简介</h1><p>这一章是 socket 编程介绍。读者应该有基本的计算机网络知识，但不是必须有网络编程经验。本书不会包含 socket API 的细节，建议读者学习本书的同时去阅读 API 手册和其他网络编程教程。(推荐一个学习 socket API 的材料： <a target="_blank" rel="noopener" href="https://beej.us/">https://beej.us/</a>)</p>
<p>Redis 是一个 server&#x2F;client 系统。多个客户端连接到一个服务器，服务器从 TCP 连接上收到请求，并发回响应。在开始 socket 编程之前，先要学习几个 Linux 系统调用。</p>
<p><code>socket()</code> 系统调用返回一个 fd 。如果你不熟悉 Unix 操作系统的话，我粗略地解释一下“fd”：一个 fd 就是一个整数，指向 Linux 内核中的某个对象，比如一个 TCP 连接，一个磁盘上的文件，一个监听端口，或者其他资源等。</p>
<p><code>bind()</code> 和 <code>listen()</code> 系统调用：<code>bind()</code> 将一个地址关联到一个 socket fd 上，<code>listen()</code> 使得我们能够接受到这个地址上的连接。</p>
<p><code>accept</code> 接收一个监听 fd 。当一个客户端连接到了监听地址上，<code>accept</code> 会返回一个 fd ，代表这个连接。下面是一段解释一般服务器工作流程的伪代码：</p>
<p>（注：本文中使用的伪代码语法很像 Python ，所以翻译代码段使用 Python 辅助语法高亮，实际并不是 Python）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fd = socket()</span><br><span class="line">bind(fd, address)</span><br><span class="line">listen(fd)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn_fd = accept(fd)</span><br><span class="line">    do_something_with(conn_fd)</span><br><span class="line">    close(conn_fd)</span><br></pre></td></tr></table></figure>

<p><code>read()</code> 系统调用会从 TCP 连接上读取数据，<code>write()</code> 系统调用则发送数据。<code>close()</code> 系统调用会销毁 fd 指向的内核资源，并回收这个 fd 。</p>
<p>我们介绍完了服务端网络编程所需要的系统调用。对于客户端而言，<code>connect()</code> 系统调用接受一个 socket fd 和一个地址，并向这个地址发起一个 TCP 连接。下面是客户端的伪代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fd = socket()</span><br><span class="line">connect(fd, address)</span><br><span class="line">do_something_with(fd)</span><br><span class="line">close(fd)</span><br></pre></td></tr></table></figure>

<p>下一章开始就会使用真正的代码了。</p>
<h1 id="Hello-服务器-x2F-客户端"><a href="#Hello-服务器-x2F-客户端" class="headerlink" title="Hello 服务器&#x2F;客户端"></a>Hello 服务器&#x2F;客户端</h1><p>本章继续介绍 socket 编程。我们会编写两个程序（不完整，跑不起来）来演示上一章的系统调用。第一个程序是一个服务器，它与客户端建立连接，读取一条信息，并写回一条响应。第二个程序是一个客户端，他发起到服务器的连接，发送一条信息，并接收一条响应。我们先来写服务器。</p>
<p>首先，需要获取一个 socket fd：<code>int fd = socket(AF_INET, SOCK_STREAM, 0);</code></p>
<p><code>AF_INET</code> 用于 IPv4 ，对于 IPv6 或者双栈协议，可以使用 <code>AF_INET6</code> 。简便起见，整本书中，我们都使用 <code>AF_INET</code> 。</p>
<p><code>SOCK_STREAM</code> 用于 TCP ，本书中我们不会用到 TCP 以外的传输层协议。书中 <code>socket()</code> 的 3 个参数一直都是固定的。</p>
<p>接下来，我们要介绍一个新的系统调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">setsockopt</span>(fd, SOL_SOCKET, SO_REUSEADDR, &amp;val, <span class="built_in">sizeof</span>(val));</span><br></pre></td></tr></table></figure>

<p><code>setsockopt()</code> 调用用于对 socket 进行各种配置。上面的调用例子启用了 <code>SO_REUSEADDR</code> 选项。如果不启动这个选项，服务器在重启对时候就无法绑定到同一个地址了。这里给读者留一个练习：查清楚 <code>SO_REUSEADDR</code> 到底是什么，有什么用？</p>
<blockquote>
<p><code>SO_REUSEADDR</code> 选项意为允许服务器 bind 一个地址，即使这个地址当前已经存在已建立的连接。例如，假设服务器与一个客户端在一个地址上建立了连接，此时服务器关闭，根据 TCP 协议，和客户端的连接进入 TIME_WAIT 状态，此时服务器重启，之前的地址上的连接还未关闭，若未开启 <code>SO_REUSEADDR</code> ，就会无法绑定地址。</p>
</blockquote>
<p>下一步是 <code>bind()</code> 和 <code>listen()</code> ，我们就绑定通用地址 <code>0.0.0.0:1234</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr = &#123;&#125;;</span><br><span class="line"><span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line">addr.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);</span><br><span class="line">addr.sin_addr.s_addr = <span class="built_in">htonl</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">bind</span>(fd, (<span class="type">const</span> <span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr))) &#123;</span><br><span class="line">    <span class="built_in">die</span>(<span class="string">&quot;bind()&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">listen</span>(fd, <span class="number">10</span>)) &#123;</span><br><span class="line">    <span class="built_in">die</span>(<span class="string">&quot;listen()&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环处理各个连接并做一些事情：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// accept</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_addr;</span><br><span class="line">    <span class="type">socklen_t</span> cliend_addr_len = <span class="built_in">sizeof</span>(client_addr);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;client_addr, <span class="number">0</span>, cliend_addr_len);</span><br><span class="line">    <span class="type">int</span> conn_fd = <span class="built_in">accept</span>(fd, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;cliend_addr_len);</span><br><span class="line">    <span class="keyword">if</span> (conn_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;   <span class="comment">// error</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">do_something</span>(conn_fd);</span><br><span class="line">    <span class="built_in">close</span>(conn_fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>do_something</code> 这一函数简单进行一次读和一次写即可：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_something</span><span class="params">(<span class="type">int</span> conn_fd)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> rbuf[<span class="number">64</span>] = &#123;&#125;;</span><br><span class="line">    <span class="type">ssize_t</span> n = <span class="built_in">read</span>(conn_fd, rbuf, <span class="built_in">sizeof</span>(rbuf) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;read() error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Client says: %s\n&quot;</span>, rbuf);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* wbuf = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="built_in">write</span>(conn_fd, wbuf, <span class="built_in">strlen</span>(wbuf));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到 <code>read()</code> 和 <code>write()</code> 这两个调用会返回读取&#x2F;写入的字节数，实际编程过程中程序员必须处理这些函数的返回值，但是在这一章里，我为了简洁而省略了许多东西，所以这一章中的代码其实不是网络编程的正确姿势。</p>
<p>客户端的代码会简单很多：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">die</span>(<span class="string">&quot;socket()&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_addr;</span><br><span class="line"><span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(server_addr));</span><br><span class="line">server_addr.sin_family = AF_INET;</span><br><span class="line">server_addr.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);</span><br><span class="line">server_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_LOOPBACK);</span><br><span class="line"><span class="type">int</span> rv = <span class="built_in">connect</span>(fd, (<span class="type">const</span> sockaddr*)&amp;server_addr, <span class="built_in">sizeof</span>(server_addr));</span><br><span class="line"><span class="keyword">if</span> (rv &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">die</span>(<span class="string">&quot;connect()&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* msg = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">write</span>(fd, msg, <span class="built_in">strlen</span>(msg));</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> rbuf[<span class="number">64</span>] = &#123;&#125;;</span><br><span class="line"><span class="type">int</span> n = <span class="built_in">read</span>(fd, rbuf, <span class="built_in">sizeof</span>(rbuf) - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">die</span>(<span class="string">&quot;read()&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Server says: %s\n&quot;</span>, rbuf);</span><br><span class="line"><span class="built_in">close</span>(fd);</span><br></pre></td></tr></table></figure>

<p>用以下命令编译代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -Wall -Wextra -O2 -g 03_server.cpp -o server</span><br><span class="line">g++ -Wall -Wextra -O2 -g 03_client.cpp -o client</span><br></pre></td></tr></table></figure>

<p>在一个窗口中运行 <code>./server</code> ，另一个窗口运行 <code>./client</code> ，你会见到如下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ./server </span><br><span class="line">Client says: hello</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ./client </span><br><span class="line">Server says: world</span><br></pre></td></tr></table></figure>

<p>另一个给读者的练习：阅读一下本章用到的 API 的手册或者是在线教程，保证你知道如何找到这些 API 的使用帮助，因为这本书中不包含这些 API 的使用细节。</p>
<p>本章源代码：</p>
<blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://build-your-own.org/redis/03/03_client.cpp.htm">03_client.cpp</a></li>
<li><a target="_blank" rel="noopener" href="https://build-your-own.org/redis/03/03_server.cpp.htm">03_server.cpp</a></li>
</ul>
</blockquote>
<h1 id="协议解析"><a href="#协议解析" class="headerlink" title="协议解析"></a>协议解析</h1><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>我们的服务器要能够处理来自客户端的多个请求，所以我们需要实现某些“协议”，至少要能把请求从 TCP 字节流中分离出来。最简单的一种提取请求的方法就是在请求头声明整个请求的长度。我们用下面这种格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+-----+------+-----+------+--------</span><br><span class="line">| len | msg1 | len | msg2 | more...</span><br><span class="line">+-----+------+-----+------+--------</span><br></pre></td></tr></table></figure>

<p>这个协议包括两部分：一个 4 字节的小端序整型，表示请求的长度，以及一个变长的请求体。</p>
<p>在上一章的代码基础上，我们要修改一下服务器的循环，来处理多个请求：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// accept</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_addr;</span><br><span class="line">    <span class="type">socklen_t</span> cliend_addr_len = <span class="built_in">sizeof</span>(client_addr);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;client_addr, <span class="number">0</span>, cliend_addr_len);</span><br><span class="line">    <span class="type">int</span> conn_fd = <span class="built_in">accept</span>(fd, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;cliend_addr_len);</span><br><span class="line">    <span class="keyword">if</span> (conn_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;   <span class="comment">// error</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int32_t</span> err = <span class="built_in">one_request</span>(conn_fd);</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(conn_fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>one_request</code> 函数只会解析一个请求，并进行响应，直到出现错误或者客户端关闭连接。在我们讲到后面的事件循环章节之前，我们的服务器一次只能接收一个连接。</p>
<h2 id="I-x2F-O-辅助函数"><a href="#I-x2F-O-辅助函数" class="headerlink" title="I&#x2F;O 辅助函数"></a>I&#x2F;O 辅助函数</h2><p>在编写 <code>one_request</code> 函数之前，我们先增加两个辅助函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int32_t</span> <span class="title">read_full</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span>* buf, <span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">ssize_t</span> rv = <span class="built_in">read</span>(fd, buf, n);</span><br><span class="line">        <span class="keyword">if</span> (rv &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// error or unexpected EOF</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">assert</span>((<span class="type">size_t</span>)rv &lt;= n);</span><br><span class="line">        n -= rv, buf += rv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int32_t</span> <span class="title">write_all</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span>* buf, <span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">ssize_t</span> rv = <span class="built_in">write</span>(fd, buf, n);</span><br><span class="line">        <span class="keyword">if</span> (rv &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">assert</span>((<span class="type">size_t</span>)rv &lt;= n);</span><br><span class="line">        n -= rv, buf += rv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意两点：</p>
<ol>
<li><code>read()</code> 系统调用会返回内核中所有可读的数据，没有数据可读的话就会阻塞，若没有读到足够的数据则需要由应用自己处理。<code>read_full</code> 函数的作用就是在读到 <code>n</code> 字节的数据之前一直向内核请求读。</li>
<li>类似地，如果内核缓冲区满了，<code>write</code> 系统调用可能只读取到部分数据，当 <code>write</code> 写入的数据比我们预期的少的时候，必须一直尝试发送直到发完 <code>n</code> 字节的数据。</li>
</ol>
<h2 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h2><p><code>one_request</code> 函数担当了这项重任：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int32_t</span> <span class="title">one_request</span><span class="params">(<span class="type">int</span> conn_fd)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> rbuf[<span class="number">4</span> + k_max_msg + <span class="number">1</span>] = &#123;&#125;;</span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int32_t</span> err = <span class="built_in">read_full</span>(conn_fd, rbuf, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;EOF\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;read() error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">uint32_t</span> len = <span class="number">0</span>;   <span class="comment">// assume little endian</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;len, rbuf, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (len &gt; k_max_msg) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;reading message too long: %d.\n&quot;</span>, len);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// request body</span></span><br><span class="line">    err = <span class="built_in">read_full</span>(conn_fd, rbuf + <span class="number">4</span>, len);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;read() error.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do_something</span></span><br><span class="line">    rbuf[<span class="number">4</span> + len] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Client says: %s\n&quot;</span>, rbuf + <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reply using the same protocol</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> reply[] = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="type">char</span> wbuf[<span class="number">4</span> + <span class="built_in">sizeof</span>(reply)];   </span><br><span class="line">    len = (<span class="type">uint32_t</span>)<span class="built_in">sizeof</span>(reply);</span><br><span class="line">    <span class="built_in">memcpy</span>(wbuf, &amp;len, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(wbuf + <span class="number">4</span>, reply, len);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">write_all</span>(conn_fd, wbuf, <span class="number">4</span> + len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了方便，我们给请求大小设置了一个最大值，用一个足够大的缓冲区来存储请求。在解析请求的时候，字节序是一个要考虑的因素，但和我们今天的内容不太相关，所以我们直接用 <code>memcpy</code> 来拷贝整数。</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>客户端发送请求并作出响应的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int32_t</span> <span class="title">query</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span>* text)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> len = (<span class="type">uint32_t</span>)<span class="built_in">strlen</span>(text);</span><br><span class="line">    <span class="keyword">if</span> (len &gt; k_max_msg) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Sending message too long.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> wbuf[<span class="number">4</span> + k_max_msg] = &#123;&#125;;</span><br><span class="line">    <span class="built_in">memcpy</span>(wbuf, &amp;len, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(wbuf + <span class="number">4</span>, text, len);</span><br><span class="line">    <span class="keyword">if</span> (<span class="type">int32_t</span> err = <span class="built_in">write_all</span>(fd, wbuf, <span class="number">4</span> + len)) &#123;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4 bytes header</span></span><br><span class="line">    <span class="type">char</span> rbuf[<span class="number">4</span> + k_max_msg + <span class="number">1</span>] = &#123;&#125;;</span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int32_t</span> err = <span class="built_in">read_full</span>(fd, rbuf, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;EOF\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;read() error\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;len, rbuf, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (len &gt; k_max_msg) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;reading message too long: %d.\n&quot;</span>, len);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reply body</span></span><br><span class="line">    err = <span class="built_in">read_full</span>(fd, rbuf + <span class="number">4</span>, len);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;read() error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Server says: %s\n&quot;</span>, rbuf + <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>发送多个请求来测试我们的服务器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">die</span>(<span class="string">&quot;socket()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_addr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);</span><br><span class="line">    server_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_LOOPBACK);</span><br><span class="line">    <span class="type">int</span> rv = <span class="built_in">connect</span>(fd, (<span class="type">const</span> sockaddr*)&amp;server_addr, <span class="built_in">sizeof</span>(server_addr));</span><br><span class="line">    <span class="keyword">if</span> (rv &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">die</span>(<span class="string">&quot;connect()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int32_t</span> err = <span class="built_in">query</span>(fd, <span class="string">&quot;hello1&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">goto</span> L_DONE;</span><br><span class="line">    &#125;</span><br><span class="line">    err = <span class="built_in">query</span>(fd, <span class="string">&quot;hello2&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">goto</span> L_DONE;</span><br><span class="line">    &#125;</span><br><span class="line">    err = <span class="built_in">query</span>(fd, <span class="string">&quot;hello3&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">goto</span> L_DONE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">L_DONE:</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行服务器和客户端：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># ./server </span><br><span class="line">Client says: hello1</span><br><span class="line">Client says: hello2</span><br><span class="line">Client says: hello3</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"># ./client </span><br><span class="line">Server says: world</span><br><span class="line">Server says: world</span><br><span class="line">Server says: world</span><br></pre></td></tr></table></figure>

<h2 id="多聊两句协议设计"><a href="#多聊两句协议设计" class="headerlink" title="多聊两句协议设计"></a>多聊两句协议设计</h2><p>在设计协议的时候要考虑很多内容，你可以看看现有的协议来学习一下各方面的权衡。</p>
<h3 id="文本-vs-二进制"><a href="#文本-vs-二进制" class="headerlink" title="文本 vs 二进制"></a>文本 vs 二进制</h3><p>设计协议要做的第一个决定是文本 vs 二进制。文本协议的好处是人类可读，容易调试，最著名的代表就是 HTTP 协议（不是新的那个）。</p>
<p>文本协议的缺点是其复杂性，即使最简单的文本协议也更难解析、更易出错。你可以尝试比较一下 Redis 协议与本书的协议。</p>
<p>为什么文本协议不好解析呢？因为里面有变长的字符串，解析协议的代码会包含大量的长度计算，边界检查和决策。比方说你想解析一个十进制文本表示的整数“1234”，那么对每一个字节，你都得检查缓冲区末尾，以及这个整数是否完结，相比之下，一个二进制的宽度确定的整数要简单得多。</p>
<p>上面的例子引出了一个设计协议的小 tip：避免非必要的变长部分，变长部分越少，解析越简单，安全性的 bug 越少。假设你想在你的协议中加入一个字符串，考虑一下能否设计成定长的字符串，或者这个字符串到底有没有必要加。</p>
<h3 id="流式数据（Streaming-Data）"><a href="#流式数据（Streaming-Data）" class="headerlink" title="流式数据（Streaming Data）"></a>流式数据（Streaming Data）</h3><p>我们的协议在头部包含了消息的长度，然而，现实世界的协议通常使用不太明显的方法来指示消息的结束。一些应用支持连续的“流式传输”数据，而不知道输出的总长度。一个很好的例子是 HTTP 协议中的“分块传输编码（Chunked Transfer Encoding）”。</p>
<p>分块编码将传入数据封装为一个消息格式，该格式以消息的长度开头。客户端接收到一系列消息，直到特殊的消息指示流的结束。</p>
<p>也有另一种不太好的方法来实现这一点：使用一种特殊符号（分隔符）来表明流的结尾。这样做的问题在于载荷数据中就不能包含这个符号，你需要一些“转义”机制，这搞得事情很复杂。</p>
<h3 id="进一步的考虑"><a href="#进一步的考虑" class="headerlink" title="进一步的考虑"></a>进一步的考虑</h3><p>解析协议的代码需要至少两次 <code>read()</code> 系统调用。我们可以通过“缓冲 I&#x2F;O（Buffered I&#x2F;O）”来减少系统调用的次数，意思就是一次读出尽可能多的数据到一个缓冲区中，然后尝试从缓冲区中解析多个请求。建议读者作为练习来尝试一下，这会对理解后面的章节很有帮助。</p>
<p>在设计和实现协议的时候，有一些新手很容易犯的错误：</p>
<blockquote>
<p>错误 1：不处理 <code>read</code> 和 <code>write</code> 的返回值。</p>
</blockquote>
<p>这两个函数读到的数据有可能会比你期望的少，看一下 <code>read_full</code> 这个函数注意点，在事件循环中这也是个常见的错误。</p>
<blockquote>
<p>错误 2：不知道怎样表示消息的结尾。</p>
</blockquote>
<p>人们经常以为 <code>read</code> 和 <code>write</code> 系统调用得到的是“消息”而不是字节流，导致协议解析不出来。早期版本的HTTP也存在这个缺陷：没有Content-Length头部或分块编码的HTTP连接无法用于多个请求。</p>
<blockquote>
<p>错误 3：非必要的复杂性</p>
</blockquote>
<p>请看协议设计的部分。</p>
<p>本章源代码：</p>
<blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://build-your-own.org/redis/04/04_client.cpp.htm">04_client.cpp</a></li>
<li><a target="_blank" rel="noopener" href="https://build-your-own.org/redis/04/04_server.cpp.htm">04_server.cpp</a></li>
</ul>
</blockquote>
<h1 id="事件循环和非阻塞-I-x2F-O"><a href="#事件循环和非阻塞-I-x2F-O" class="headerlink" title="事件循环和非阻塞 I&#x2F;O"></a>事件循环和非阻塞 I&#x2F;O</h1><p>服务端网络编程中，有 3 种处理并发连接的方式，分别是：多进程（forking）、多线程（multi-threading）和事件循环（event loop）。多进程方式为每个连接创建一个新的进程来实现并发，多线程则用线程来代替进程，事件循环方式使用轮询（polling）和非阻塞 I&#x2F;O ，并且一般跑在单线程上。因为线程和进程的开销，大多数现代工业级软件的网络部分都使用事件循环的方式。</p>
<p>我们服务器的事件循环的简化伪代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">all_fds = [...]</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    active_fds = poll(all_fds)</span><br><span class="line">    <span class="keyword">for</span> each fd <span class="keyword">in</span> active_fds:</span><br><span class="line">        do_something_with(fd)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_something_with</span>(<span class="params">fd</span>):</span><br><span class="line">    <span class="keyword">if</span> fd <span class="keyword">is</span> a listening socket:</span><br><span class="line">        add_new_client(fd)</span><br><span class="line">    <span class="keyword">elif</span> fd <span class="keyword">is</span> a client connection:</span><br><span class="line">        <span class="keyword">while</span> work_not_done:</span><br><span class="line">            do_something_to_client(fd)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_something_to_client</span>(<span class="params">fd</span>):</span><br><span class="line">    <span class="keyword">if</span> should_read_from(fd):</span><br><span class="line">        data = read_util_EAGAIN(fd)</span><br><span class="line">        process_incoming_data(data)</span><br><span class="line">    <span class="keyword">while</span> should_write_to(fd):</span><br><span class="line">        write_util_EAGAIN(fd)</span><br><span class="line">    <span class="keyword">if</span> should_close(fd):</span><br><span class="line">        destroy_client(fd)</span><br></pre></td></tr></table></figure>

<p>我们不仅处理 fd （进行读、写、接收），还使用 <code>poll</code> 函数来告诉我们哪些 fd 上可以<em>立刻</em>进行操作而无需阻塞。当我们在一个 fd 上进行 I&#x2F;O 操作时，这个操作应该在非阻塞模式下进行。</p>
<p>在阻塞模式下，<code>read</code> 会在内核中没有可读数据的时候阻塞调用者，<code>write</code> 会在内核缓冲区满的时候阻塞调用者，<code>accept</code> 会在内核队列中没有新到来的连接时阻塞调用者。在非阻塞模式下，这些操作要么不阻塞直接执行成功，要么失败并将 errno 设为 <code>EAGAIN</code> ，表示“还没准备好”。执行失败并且带有 <code>EAGAIN</code> 的操作必须在 <code>poll</code> 通知就绪之后进行重试。</p>
<p><code>poll</code> 是事件循环中<em>唯一的</em>阻塞操作，除此以外的必须都是非阻塞的，因此单线程也能处理大量并发连接。所有阻塞的网络 I&#x2F;O API ，如 <code>read</code>、<code>write</code> 和 <code>accept</code>， 都有非阻塞模式。有一些没有非阻塞模式的 API 则需要在线程池中执行，比如 <code>gethostbyname</code> 和磁盘 I&#x2F;O ，这点会在后面的章节讲到。同样的，事件循环中必须实现定时器（timer），因为我们不能在事件循环用 <code>sleep</code> 等待。</p>
<p>把一个 fd 设置为非阻塞模式的系统调用是 <code>fcntl</code> ：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">fd_set_nb</span><span class="params">(<span class="type">int</span> fd)</span> </span>&#123;</span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> flags = <span class="built_in">fcntl</span>(fd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (errno) &#123;</span><br><span class="line">        <span class="built_in">die</span>(<span class="string">&quot;fcntl error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flags |= O_NONBLOCK;</span><br><span class="line"></span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    (<span class="type">void</span>)<span class="built_in">fcntl</span>(fd, F_SETFL, flags);</span><br><span class="line">    <span class="keyword">if</span> (errno) &#123;</span><br><span class="line">        <span class="built_in">die</span>(<span class="string">&quot;fcntl error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Linux 中，除了 <code>poll</code> 系统调用，还有 <code>select</code> 和 <code>epoll</code>。古老的 <code>select</code> 系统调用和 <code>poll</code> 差不多，但是 fd 的最大数量被限制得很小，导致它被现代应用淘汰了。<code>epoll</code> API 包括 3 个系统调用：<code>epoll_create</code>，<code>epoll_wait</code>，和 <code>epoll_ctl</code>。<code>epoll</code> API 是有状态的，它并不是把 fd 的集合作为参数，而是用 <code>epoll_ctl</code> 来操作一个由 <code>epoll_create</code> 创建出来的 fd 集合，<code>epoll_wait</code> 就在该集合上执行。</p>
<p>下一章中我们会使用 <code>poll</code> 系统调用，因为它的代码相比有状态的 <code>epoll</code> 来说会比较少。但是真实世界的项目中通常更倾向于使用 <code>epoll</code>，因为随着 fd 数量增多，<code>poll</code> 可能会变得太大。</p>
<h1 id="事件循环的实现"><a href="#事件循环的实现" class="headerlink" title="事件循环的实现"></a>事件循环的实现</h1><p>这一章会介绍一个 echo 服务器的真实 C++ 代码。</p>
<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><code>struct Conn</code> 的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    STATE_REQ = <span class="number">0</span>,</span><br><span class="line">    STATE_RES = <span class="number">1</span>,</span><br><span class="line">    STATE_END = <span class="number">2</span>   <span class="comment">// mark the connection for deletion</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Conn</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">uint32_t</span> state = STATE_REQ;</span><br><span class="line">    <span class="comment">// buffer for reading</span></span><br><span class="line">    <span class="type">size_t</span> rbuf_size = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint8_t</span> rbuf[<span class="number">4</span> + k_max_msg];</span><br><span class="line">    <span class="comment">// buffer for writing</span></span><br><span class="line">    <span class="type">size_t</span> wbuf_size = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> wbuf_sent = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint8_t</span> wbuf[<span class="number">4</span> + k_max_msg];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们需要读和写操作的缓冲区，因为是非阻塞模式编程，所以 I&#x2F;O 操作经常延迟。</p>
<p><code>state</code> 用来决定在这个连接上进行的是哪种操作，一个进行中的连接有两种状态。<code>STATE_REQ</code> 表示现在要从这个连接中读取请求，而 <code>STATE_RES</code> 表示要从该连接向客户端返回响应。</p>
<p>事件循环的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">die</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> val = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">setsockopt</span>(fd, SOL_SOCKET, SO_REUSEADDR, &amp;val, <span class="built_in">sizeof</span>(val));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr = &#123;&#125;;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);</span><br><span class="line">    addr.sin_addr.s_addr = <span class="built_in">htonl</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(fd, (<span class="type">const</span> <span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr))) &#123;</span><br><span class="line">        <span class="built_in">die</span>(<span class="string">&quot;bind()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(fd, <span class="number">10</span>)) &#123;</span><br><span class="line">        <span class="built_in">die</span>(<span class="string">&quot;listen()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a map of all client connections, keyed by fd</span></span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, Conn*&gt; fd2conn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set listen fd to non blocking mode</span></span><br><span class="line">    <span class="built_in">set_fd_nb</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// event loop</span></span><br><span class="line">    std::vector&lt;<span class="keyword">struct</span> pollfd&gt; poll_args;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// prepare the arguments of the poll()</span></span><br><span class="line">        poll_args.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="comment">// for convenience, the listening fd is put in the first position</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">pollfd</span> pfd = &#123;fd, POLLIN, <span class="number">0</span>&#125;;</span><br><span class="line">        poll_args.<span class="built_in">push_back</span>(pfd);</span><br><span class="line">        <span class="comment">// connection fds</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [_, conn] : fd2conn) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!conn) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">pollfd</span> pfd = &#123;&#125;;</span><br><span class="line">            pfd.fd = conn-&gt;fd;</span><br><span class="line">            pfd.events = (conn-&gt;state == STATE_REQ) ? POLLIN : POLLOUT;</span><br><span class="line">            pfd.events = pfd.events | POLLERR;</span><br><span class="line">            poll_args.<span class="built_in">push_back</span>(pfd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// poll for active fds</span></span><br><span class="line">        <span class="comment">// the timeout argument doesn&#x27;t matter here</span></span><br><span class="line">        <span class="type">int</span> rv = <span class="built_in">poll</span>(poll_args.<span class="built_in">data</span>(), (<span class="type">nfds_t</span>)poll_args.<span class="built_in">size</span>(), <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">if</span> (rv &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">die</span>(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// process active connections</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; poll_args.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (poll_args[i].revents) &#123;</span><br><span class="line">                Conn* conn = fd2conn[poll_args[i].fd];</span><br><span class="line">                <span class="built_in">connection_io</span>(conn);</span><br><span class="line">                <span class="keyword">if</span> (conn-&gt;state == STATE_END) &#123;</span><br><span class="line">                    <span class="comment">// client closed normally, or something bad happened</span></span><br><span class="line">                    <span class="comment">// destroy this connection</span></span><br><span class="line">                    fd2conn[conn-&gt;fd] = <span class="literal">nullptr</span>;</span><br><span class="line">                    (<span class="type">void</span>)<span class="built_in">close</span>(conn-&gt;fd);</span><br><span class="line">                    <span class="built_in">free</span>(conn);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (poll_args[<span class="number">0</span>].revents) &#123;</span><br><span class="line">            (<span class="type">void</span>)<span class="built_in">accept_new_conn</span>(fd2conn, fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们事件循环的第一件事情就是为 <code>poll</code> 设置参数。监听 fd 使用 <code>POLLIN</code> 标识加入 poll 中。对于连接 fd ，其对应的 <code>Conn</code> 结构体的 state 决定了其标识。在我们的场景下，poll 标识要么是读（<code>POLLIN</code>）要么是写（<code>POLLOUT</code>），不会同时发生。如果使用 <code>epoll</code> ，那么事件循环的第一件事往往是使用 <code>epoll_ctl</code> 来更新 fd 的集合。</p>
<p><code>poll</code> 还接收一个 <code>timeout</code> 参数，可以用来实现定时器（后面的章节介绍）。目前 <code>timeout</code> 并不重要，我们先随便设置一个大点的数字。</p>
<p>在 <code>poll</code> 返回之后，它会通知我们哪些 fd 上准备好了读&#x2F;写操作，我们会相应执行。</p>
<h2 id="新的连接"><a href="#新的连接" class="headerlink" title="新的连接"></a>新的连接</h2><p><code>accept_new_conn</code> 函数会接收一个新的连接并创建一个 <code>Conn</code> 对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">conn_put</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    std::unordered_map&lt;<span class="type">int</span>, Conn*&gt;&amp; fd2conn, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> Conn* conn</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line">    fd2conn.<span class="built_in">emplace</span>(conn-&gt;fd, conn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int32_t</span> <span class="title">accept_new_conn</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    std::unordered_map&lt;<span class="type">int</span>, Conn*&gt;&amp; fd2conn, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> fd</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// accept</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_addr = &#123;&#125;;</span><br><span class="line">    <span class="type">socklen_t</span> socklen = <span class="built_in">sizeof</span>(client_addr);</span><br><span class="line">    <span class="type">int</span> connfd = <span class="built_in">accept</span>(fd, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;socklen);</span><br><span class="line">    <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;accept() error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set the new connection fd to nonblocking mode</span></span><br><span class="line">    <span class="built_in">set_fd_nb</span>(connfd);</span><br><span class="line">    <span class="comment">// creating the struct Conn</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Conn</span>* conn = (Conn*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> Conn));</span><br><span class="line">    <span class="keyword">if</span> (!conn) &#123;</span><br><span class="line">        <span class="built_in">close</span>(connfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    conn-&gt;fd = connfd;</span><br><span class="line">    conn-&gt;rbuf_size = <span class="number">0</span>;</span><br><span class="line">    conn-&gt;wbuf_sent = <span class="number">0</span>;</span><br><span class="line">    conn-&gt;wbuf_size = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">conn_put</span>(fd2conn, conn);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>connection_io</code> 函数是用于客户端连接的状态机：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">connection_io</span><span class="params">(Conn* conn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (conn-&gt;state == STATE_REQ) &#123;</span><br><span class="line">        <span class="built_in">state_req</span>(conn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (conn-&gt;state == STATE_RES) &#123;</span><br><span class="line">        <span class="built_in">state_res</span>(conn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="number">0</span>);  <span class="comment">// not expected</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="状态机：读者"><a href="#状态机：读者" class="headerlink" title="状态机：读者"></a>状态机：读者</h2><p><code>STATE_REQ</code> 状态用于读操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">state_req</span><span class="params">(Conn* conn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">try_fill_buffer</span>(conn));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">try_fill_buffer</span><span class="params">(Conn* conn)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// try to fill the buffer</span></span><br><span class="line">    <span class="built_in">assert</span>(conn-&gt;rbuf_size &lt; <span class="built_in">sizeof</span>(conn-&gt;rbuf));</span><br><span class="line">    <span class="type">ssize_t</span> rv = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">size_t</span> cap = <span class="built_in">sizeof</span>(conn-&gt;rbuf) - conn-&gt;rbuf_size;</span><br><span class="line">        rv = <span class="built_in">read</span>(conn-&gt;fd, conn-&gt;rbuf + conn-&gt;rbuf_size, cap);</span><br><span class="line">    &#125; <span class="keyword">while</span> (rv &lt; <span class="number">0</span> &amp;&amp; errno == EINTR);</span><br><span class="line">    <span class="keyword">if</span> (rv &lt; <span class="number">0</span> &amp;&amp; errno == EAGAIN) &#123;</span><br><span class="line">        <span class="comment">// got EAGAIN, stop.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rv &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;read error\n&quot;</span>);</span><br><span class="line">        conn-&gt;state = STATE_END;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rv == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (conn-&gt;rbuf_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;unexpected EOF\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;EOF\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        conn-&gt;state = STATE_END;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    conn-&gt;rbuf_size += (<span class="type">size_t</span>)rv;</span><br><span class="line">    <span class="built_in">assert</span>(conn-&gt;rbuf_size &lt; <span class="built_in">sizeof</span>(conn-&gt;rbuf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try to process requests one by one</span></span><br><span class="line">    <span class="comment">// Why is there a loop? Please read the explanation of &quot;pipelining&quot;.</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">try_one_request</span>(conn));</span><br><span class="line">    <span class="keyword">return</span> (conn-&gt;state == STATE_REQ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有很多东西要拆开来说。为了理解这个函数，我们先看上一章中的伪代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">do_something_to_client</span>(<span class="params">fd</span>):</span><br><span class="line">    <span class="keyword">if</span> should_read_from(fd):</span><br><span class="line">        data = read_until_EAGAIN(fd)</span><br><span class="line">        process_incoming_data(data)</span><br><span class="line">    <span class="comment"># code omitted...</span></span><br></pre></td></tr></table></figure>

<p><code>try_fill_buffer</code> 函数向缓冲区中填入数据。因为读缓冲区的大小是有限的，这个缓冲区可能在发生 <code>EAGAIN</code> 之前就满了，所以我们需要在读取之后立即处理数据来释放读缓冲区的空间，然后 <code>try_fill_buffer</code> 会循环直到发生 <code>EAGAIN</code> 。</p>
<p><code>read</code> 系统调用（和其他系统调用一样），需要在发生 <code>EINTR</code> 时进行重试。<code>EINTR</code> 表示系统调用被信号打断了，即使我们的应用没有用到信号，也应该进行重试。</p>
<h2 id="解析协议"><a href="#解析协议" class="headerlink" title="解析协议"></a>解析协议</h2><p><code>try_one_request</code> 函数会处理读取到的数据，但是为什么这里是个循环呢？是因为读缓冲区中有不止一个请求吗？正是如此。对于一个请求&#x2F;响应协议，客户端不会一次只发送一个请求然后就开始等待响应，客户端可能会连续发送很多请求，而并不在每个请求之后都等待响应，这种操作模式成为“流水线（pipelining）”，因此我们不能假设读缓冲区中最多只有一个请求。</p>
<p>以下是 <code>try_one_request</code> 的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">try_one_request</span><span class="params">(Conn* conn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (conn-&gt;rbuf_size &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">uint32_t</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;len, conn-&gt;rbuf, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (len &gt; k_max_msg) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;too long&quot;</span>);</span><br><span class="line">        conn-&gt;state = STATE_END;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">4</span> + len &gt; conn-&gt;rbuf_size) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// got one request, do something with it</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Client says: %.*s\n&quot;</span>, len, conn-&gt;rbuf + <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// generating echo response</span></span><br><span class="line">    <span class="built_in">memcpy</span>(conn-&gt;wbuf, &amp;len, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(conn-&gt;wbuf + <span class="number">4</span>, conn-&gt;rbuf + <span class="number">4</span>, len);</span><br><span class="line">    conn-&gt;wbuf_size = <span class="number">4</span> + len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// remove the request from the buffer</span></span><br><span class="line">    <span class="type">size_t</span> remain = conn-&gt;rbuf_size - <span class="number">4</span> - len;</span><br><span class="line">    <span class="keyword">if</span> (remain) &#123;</span><br><span class="line">        <span class="built_in">memmove</span>(conn-&gt;rbuf, conn-&gt;rbuf + <span class="number">4</span> + len, remain);</span><br><span class="line">    &#125;</span><br><span class="line">    conn-&gt;rbuf_size = remain;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// change state</span></span><br><span class="line">    conn-&gt;state = STATE_RES;</span><br><span class="line">    <span class="built_in">state_res</span>(conn);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (conn-&gt;state == STATE_REQ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>try_one_request</code> 函数一次从读缓冲区中读出一个请求，生成一个响应，并且把连接状态改为 <code>STATE_RES</code> 。</p>
<h2 id="状态机：写者"><a href="#状态机：写者" class="headerlink" title="状态机：写者"></a>状态机：写者</h2><p><code>STATE_RES</code> 状态的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">state_res</span><span class="params">(Conn* conn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">try_flush_buffer</span>(conn));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">try_flush_buffer</span><span class="params">(Conn* conn)</span> </span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> rv = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">size_t</span> remain = conn-&gt;wbuf_size - conn-&gt;wbuf_sent;</span><br><span class="line">        rv = <span class="built_in">write</span>(conn-&gt;fd, conn-&gt;wbuf + conn-&gt;wbuf_sent, remain);</span><br><span class="line">    &#125; <span class="keyword">while</span> (rv &lt; <span class="number">0</span> &amp;&amp; errno == EINTR);</span><br><span class="line">    <span class="keyword">if</span> (rv &lt; <span class="number">0</span> &amp;&amp; errno == EAGAIN) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rv &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;write error\n&quot;</span>);</span><br><span class="line">        conn-&gt;state = STATE_END;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    conn-&gt;wbuf_sent += (<span class="type">ssize_t</span>)rv;</span><br><span class="line">    <span class="built_in">assert</span>(conn-&gt;wbuf_sent &lt;= conn-&gt;wbuf_size);</span><br><span class="line">    <span class="keyword">if</span> (conn-&gt;wbuf_sent == conn-&gt;wbuf_size) &#123;</span><br><span class="line">        <span class="comment">// response was fully sent, change state back</span></span><br><span class="line">        conn-&gt;state = STATE_REQ;</span><br><span class="line">        conn-&gt;wbuf_size = <span class="number">0</span>;</span><br><span class="line">        conn-&gt;wbuf_sent = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码尝试发送数据来清理写缓冲区，一直到遇到 <code>EAGAIN</code> 为止，如果缓冲区的数据全部发送完成，就切换回 <code>STATE_REQ</code> 状态。</p>
<h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><p>为了测试我们的服务器，我们可以直接跑第 4 章的客户端程序，因为协议是一样的。但我们也可以修改客户端代码，来展示一个流水线客户端：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int32_t</span> <span class="title">send_req</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span>* text)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> len = (<span class="type">uint32_t</span>)<span class="built_in">strlen</span>(text);</span><br><span class="line">    <span class="keyword">if</span> (len &gt; k_max_msg) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Sending message too long.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> wbuf[<span class="number">4</span> + k_max_msg] = &#123;&#125;;</span><br><span class="line">    <span class="built_in">memcpy</span>(wbuf, &amp;len, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(wbuf + <span class="number">4</span>, text, len);</span><br><span class="line">    <span class="keyword">if</span> (<span class="type">int32_t</span> err = <span class="built_in">write_all</span>(fd, wbuf, <span class="number">4</span> + len)) &#123;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int32_t</span> <span class="title">read_res</span><span class="params">(<span class="type">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 4 bytes header</span></span><br><span class="line">    <span class="type">uint32_t</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> rbuf[<span class="number">4</span> + k_max_msg + <span class="number">1</span>] = &#123;&#125;;</span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int32_t</span> err = <span class="built_in">read_full</span>(fd, rbuf, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;EOF\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;read() error\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;len, rbuf, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (len &gt; k_max_msg) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;reading message too long: %d.\n&quot;</span>, len);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reply body</span></span><br><span class="line">    err = <span class="built_in">read_full</span>(fd, rbuf + <span class="number">4</span>, len);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;read() error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Server says: %s\n&quot;</span>, rbuf + <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">die</span>(<span class="string">&quot;socket()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_addr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);</span><br><span class="line">    server_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_LOOPBACK);</span><br><span class="line">    <span class="type">int</span> rv = <span class="built_in">connect</span>(fd, (<span class="type">const</span> sockaddr*)&amp;server_addr, <span class="built_in">sizeof</span>(server_addr));</span><br><span class="line">    <span class="keyword">if</span> (rv &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">die</span>(<span class="string">&quot;connect()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// multiple pipelined requests</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* query_list[] = &#123;<span class="string">&quot;hello1&quot;</span>, <span class="string">&quot;hello2&quot;</span>, <span class="string">&quot;hello3&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int32_t</span> err = <span class="built_in">send_req</span>(fd, query_list[i]);</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="keyword">goto</span> L_DONE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int32_t</span> err = <span class="built_in">read_res</span>(fd);</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="keyword">goto</span> L_DONE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">L_DONE:</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>练习：</p>
<ol>
<li>尝试在事件循环中使用 <code>epoll</code> 代替 <code>poll</code>，这应该很简单。</li>
<li>我们使用了 <code>memmove</code> 回收读缓冲区空间。但对每个请求都做 <code>memmove</code> 是没有必要的。请修改代码，只在 <code>read</code> 前进行 <code>memmove</code>。</li>
<li>在 <code>state_res</code> 函数中，我们对每一个响应都调用了 <code>write</code> 。在流水线的场景下，我们其实可以缓存多个响应然后调用 <code>write</code> 一次性发送，请注意中间可能会有写缓冲区满的情况。</li>
</ol>
<p>本章源代码：</p>
<blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://build-your-own.org/redis/06/06_client.cpp.htm">06_client.cpp</a></li>
<li><a target="_blank" rel="noopener" href="https://build-your-own.org/redis/06/06_server.cpp.htm">06_server.cpp</a></li>
</ul>
</blockquote>
<p>未完待续。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">伊织Iori</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/07/23/redis-from-scratch/">http://example.com/2023/07/23/redis-from-scratch/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">程序员和他的雀庄</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/C/">C</a><a class="post-meta__tags" href="/tags/Redis/">Redis</a></div><div class="post_share"><div class="social-share" data-image="/2023/07/23/redis-from-scratch/cover.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/11/04/rcore-notes/"><img class="next-cover" src="/2022/11/04/rcore-notes/cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">rcore 课程笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/03/27/opencv/" title="OpenCV环境配置"><img class="cover" src="/2022/03/27/opencv/cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-27</div><div class="title">OpenCV环境配置</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">伊织Iori</div><div class="author-info__description">不太有干劲的普通人</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/MoyusiteruIori"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/MoyusiteruIori" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/y.meng1@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://twitter.com/111Iori" target="_blank" title="Twitter"><i class="fab fa-twitter"></i></a><a class="social-icon" href="tencent://message/?uin=1037655483" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Critter 博客翻译填坑中</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%99%E6%9C%AC%E4%B9%A6%E6%98%AF%E5%86%99%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">这本书是写什么的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E8%BF%99%E6%9C%AC%E4%B9%A6%E8%83%BD%E5%AD%A6%E5%88%B0%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">从这本书能学到什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BB%8E-0-%E5%BC%80%E5%A7%8B%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">为什么要从 0 开始？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%9C%AC%E4%B9%A6%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">如何使用本书？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Socket-%E7%AE%80%E4%BB%8B"><span class="toc-number">2.</span> <span class="toc-text">Socket 简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hello-%E6%9C%8D%E5%8A%A1%E5%99%A8-x2F-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">3.</span> <span class="toc-text">Hello 服务器&#x2F;客户端</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">协议解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E8%A7%88"><span class="toc-number">4.1.</span> <span class="toc-text">总览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-x2F-O-%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.</span> <span class="toc-text">I&#x2F;O 辅助函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="toc-number">4.3.</span> <span class="toc-text">解析器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">4.4.</span> <span class="toc-text">客户端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">4.5.</span> <span class="toc-text">测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%81%8A%E4%B8%A4%E5%8F%A5%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.6.</span> <span class="toc-text">多聊两句协议设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%9C%AC-vs-%E4%BA%8C%E8%BF%9B%E5%88%B6"><span class="toc-number">4.6.1.</span> <span class="toc-text">文本 vs 二进制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E5%BC%8F%E6%95%B0%E6%8D%AE%EF%BC%88Streaming-Data%EF%BC%89"><span class="toc-number">4.6.2.</span> <span class="toc-text">流式数据（Streaming Data）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%9A%84%E8%80%83%E8%99%91"><span class="toc-number">4.6.3.</span> <span class="toc-text">进一步的考虑</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E-I-x2F-O"><span class="toc-number">5.</span> <span class="toc-text">事件循环和非阻塞 I&#x2F;O</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.</span> <span class="toc-text">事件循环的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A7%88"><span class="toc-number">6.1.</span> <span class="toc-text">概览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B0%E7%9A%84%E8%BF%9E%E6%8E%A5"><span class="toc-number">6.2.</span> <span class="toc-text">新的连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%9C%BA%EF%BC%9A%E8%AF%BB%E8%80%85"><span class="toc-number">6.3.</span> <span class="toc-text">状态机：读者</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE"><span class="toc-number">6.4.</span> <span class="toc-text">解析协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%9C%BA%EF%BC%9A%E5%86%99%E8%80%85"><span class="toc-number">6.5.</span> <span class="toc-text">状态机：写者</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95-1"><span class="toc-number">6.6.</span> <span class="toc-text">测试</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/07/23/redis-from-scratch/" title="用 C/C++ 写一个自己的 Redis"><img src="/2023/07/23/redis-from-scratch/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="用 C/C++ 写一个自己的 Redis"/></a><div class="content"><a class="title" href="/2023/07/23/redis-from-scratch/" title="用 C/C++ 写一个自己的 Redis">用 C/C++ 写一个自己的 Redis</a><time datetime="2023-07-23T13:27:36.000Z" title="发表于 2023-07-23 21:27:36">2023-07-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/04/rcore-notes/" title="rcore 课程笔记"><img src="/2022/11/04/rcore-notes/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="rcore 课程笔记"/></a><div class="content"><a class="title" href="/2022/11/04/rcore-notes/" title="rcore 课程笔记">rcore 课程笔记</a><time datetime="2022-11-04T13:28:00.000Z" title="发表于 2022-11-04 21:28:00">2022-11-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/23/generic-unionfind-rust/" title="用 Rust 写一个泛型并查集"><img src="/2022/10/23/generic-unionfind-rust/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="用 Rust 写一个泛型并查集"/></a><div class="content"><a class="title" href="/2022/10/23/generic-unionfind-rust/" title="用 Rust 写一个泛型并查集">用 Rust 写一个泛型并查集</a><time datetime="2022-10-23T07:58:39.000Z" title="发表于 2022-10-23 15:58:39">2022-10-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/20/os-learning-record/" title="2022秋冬开源操作系统训练营学习日志"><img src="/2022/10/20/os-learning-record/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2022秋冬开源操作系统训练营学习日志"/></a><div class="content"><a class="title" href="/2022/10/20/os-learning-record/" title="2022秋冬开源操作系统训练营学习日志">2022秋冬开源操作系统训练营学习日志</a><time datetime="2022-10-20T10:13:43.000Z" title="发表于 2022-10-20 18:13:43">2022-10-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/27/opencv/" title="OpenCV环境配置"><img src="/2022/03/27/opencv/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OpenCV环境配置"/></a><div class="content"><a class="title" href="/2022/03/27/opencv/" title="OpenCV环境配置">OpenCV环境配置</a><time datetime="2022-03-27T06:06:58.000Z" title="发表于 2022-03-27 14:06:58">2022-03-27</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/2023/07/23/redis-from-scratch/cover.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 伊织Iori</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>