---
title: 四月开始的保研挣扎日志
date: 2023-04-04 23:09:05
tags:
    - 保研
categories: 保研
keywords: '保研'
description: 菜狗怎样自我救赎
cover: cover.png
---

## 4月4日

专业课复习：
- 哈夫曼树和哈夫曼编码
- 希尔排序和归并排序
- AVL 树的调整

项目：
- 完成了 myserver 的文档
    - 写新的项目基本上到此为止了，接下来以复习之前的项目为主

算法题：
- 每日一题是 hard 区间 dp ，放弃
- 739 每日温度，单调栈
    - 求每个元素最左/右边最xxx的元素，应该能第一时间想到单调栈

- 975 奇偶跳，dp + 二分
    - `std::map::upper_bound(x)`：返回值指向首个大于 `x` 的元素
    - `std::map::lower_bound(x)`：返回值指向首个不小于 `x` 的元素


## 4月5日

**完成了初版简历**，花了一下午，但还有待改进

项目复盘：
- `myserver::Address::lookup` 的实现：
    - `getaddrinfo` 根据域名获取地址
    - 传入一个字符串 host 表示域名，一个字符串 service 表示端口（可以是 `"http"`、`"ftp"` 等固定端口的服务）
    - 传入一个 `addrinfo *` 类型的 hint，表示想获得什么样的信息，例如把 hint 的 `ai_type` 字端设为 `SOCK_DGRAM` 只获取 UDP 接口的信息
    - 传入一个 `addrinfo **` 类型的 result 指向返回的结果链表
    - 还有一个参数 `ai_flags`，传入 `AI_CANONNAME` 要求返回主机的规范名称，传入 `AI_NUMERICHOST` 要求地址是数字串
    - `addrinfo` 包含的字端和创建 socket 要设置的那些差不多，就是 `ai_family`、`ai_type`、`ai_protocol`、那些东西，另外包含一个 `ai_addrlen` 和一个 `ai_addr` 方便你取出地址，另外一个 `ai_cannoname` 在某些情况下会包含节点的正规名，然后还有一个 `addrinfo *` 用来形成链表 
    - `memchr(const void *buf, int ch, size_t count)` 从 buf 的前 count 个区域查找 ch
    - `getaddrinfo` 不区分协议，`gethostbyname` 和 `gethostbyaddr` 只支持 v4 协议

- `myserver::Address::interface_address` 的实现：
    - `getifaddrs` 获取网卡的地址信息
    - 传入一个 `ifaddrs **` 即可，返回包含一个所有网卡信息的链表
    - `ifaddrs` 包含 `ifa_name` 网卡名，`sockaddr *ifa_addr, *ifa_netmask` 网卡地址和子网掩码
    - 还包含一个 `union` ，指向一个广播地址或者一个 p2p 目的地址（没用到）

专业课复习：
- 死锁产生的必要条件：
    - 资源是互斥的
    - 线程会等待资源，并且不释放持有的资源
    - 不能抢夺资源
    - 形成循环等待

破坏以上任意一条都能解决死锁问题，但如果破坏前三条，都会改变互斥的语义，因此往往从避免循环等待入手解决

算法题：
- 2427 公因子数目，easy 题，首次尝试使用了 C++ 20 ranges ，然而 LC 并不支持。
- 48 旋转图像，应用一下线性代数，矩阵代表线性变换

## 4月6日

项目复盘：
- 关于 `myserver::Address::UnixAddress`:
    - 本地套接字的作用是进程间通信，和网络套接字类似
    - `sockaddr_un` 主要包含 108 字节的 `sun_path` 路径名，这是一个伪文件，大小永远为 0
    - 服务端 `bind` 之后，指定的 `sun_path` 中会自动生成套接字文件

<div align=center> 

{% asset_img sockaddr.png 各种socket地址 %}

</div>

- `myserver::Socket::option` 查看 socket 选项：
    - 基于 `getsockopt` 实现
    - 如果未进行 `setsockopt()` 调用，则 `getsockopt` 返回系统缺省值。
    - `getsockopt` 通过 `level` 和 `optname` 确定调用者要查看的选项，然后返回值，选项包括一些诸如 `SO_RCVBUF` 、`SO_TYPE` 之类的，具体需要查看手册
    - `setsockopt` 和 `getsockopt` 是对应的，`myserver::Socket` 中的各个设置/获取 socket 选项的方法都基于他们实现

- `myserver::Socket::bind`：ip 地址和端口号绑定到 socket

- `listen` 和 `accept`：
    - `listen` 相当于一种声明，告知内核这个 fd 是一个被动的套接字。没有 `listen` 时，内核默认假设这个套接字会调用 `connect`。
    - `accept` 用来接受客户端发起的连接，并能够获得客户端的地址
    - `connect` 由客户端调用，传入服务器的地址，向服务端发起连接

- `getpeername` 和 `getsockname`：获取对方地址和端口，获取本地地址和端口，对服务端来说 `getsockname` 没有太多卵用，但是建立 TCP 连接之后使用 `getpeername` 获取对方地址和端口可能很有用。对客户端来说，没有 `bind` 的步骤，刚创建 socket 的时候并不会分配本地地址信息，所以也不能调用 `getsockname`，但连接建立以后，可以使用 `getpeername` 获取对方的地址和端口，然而这也没什么卵用，因为你不知道对方的地址端口的话怎么调用 `connect` 去连接呢？当然，对于写框架的人来说还是有用的。
另外，对于无连接的 UDP 协议来说，不能调用 `getpeername`，但是可以调用 `getsockname`,和 TCP 一样，他的地址和端口不是在调用 `socket` 就指定了，而是在第一次调用 `sendto` 函数以后

专业课复习：
- 硬链接和软链接
    - 软链接（符号链接），`ln -s file link`
    - 硬链接，`ln file link`
    - 本质区别：软链接有自己的 inode 和 datablock，其 datablock 指向了原文件，而硬链接直接与原文件共享 inode 和 datablock。本质上硬链接和原文件是同一个文件，而软链接和原文件不是同一个文件。删除原文件后硬链接还能访问这个文件，软链接则无法访问了


<div align=center> 

{% asset_img link.png 硬链接和软链接 %}

</div>

- 希尔排序的时间复杂度为 $O(n^{\frac{3}{2}})$

- 大数定律
    - 切比雪夫大数定律：样本数量足够多时，样本平均数趋近总体平均数，不要求同分布
    - 伯努利大数定律：样本数量足够多时，事件 A 出现的频率将趋近于其概率
    - 辛钦大数定律：切比雪夫大数定律同分布情况下的特例，样本数量足够多时，样本平均数趋近其分布的数学期望

- 中心极限定理：独立同分布的样本数量足够多时，其加和近似符合正态分布

其实今天还看了半天线性代数，但是还是没有理解矩阵的行空间

算法题
- 53 最大子数组和，感觉是比较简单的 dp ，很容易看出来
- 647 回文子串，也是不太难的 dp ，注意填表顺序是从左下开始往右上填

## 4月7日

今天太忙了，做软测小组作业到现在刚回寝室，已经 4 月 8 日 00:21，来不及仔细总结，大致写一下。

项目复盘
- 关于动态链接的全局介入性，`dlfcnt.h` 中的几个函数的使用，主要是 `dlsym`

算法题
- 337 打家劫舍III，在二叉树上进行 dp ，想了半天做出来了但是内存不够，看了题解学到一招用哈希表作为 dp 数组的操作
- 128 最长连续序列 要求 O(n) 所以不能排序，所以空间换时间，对于数字 `n` ，哈希表记录 `n - 1` 和 `n + 1` 的情况

今天实在比较忙，做得太少了，明天一定狂补。

## 4月8日

项目复盘
- 性能测试
    - 压测工具：`ab-httpd-tools`
    - 单线程 1000000 请求 200 并发，短连接，qps 15000-16000
    - 同样条件下和 libev 差不多，比 nginx（13000） 好。
    - 结果 makes sense，libev 是 C 库，自然快于我们这个有很多额外开销的 cpp 库，nginx 比较复杂有较多模块
    - 长链接 qps 47000，nginx 43000

专业课
- 两节线性代数
    - 不要纠结行空间和列空间等几何意义了，不是所有几何意义都是现在能理解了的
    - A = LU 变换，E1E2E3A = U，计算 E1E2E3 的逆的时候不要先乘再逆
    - 左乘初等矩阵对应初等行变换，右乘初等矩阵对应初等列变换
    - 高斯消元的时间开销是立方级的

算法题
    - 77
    - 39

是两个没太多好说的 dfs 爆搜

搭了下这周 HCI Lab 的环境，好麻烦

## 4月9日

喵杏打了一天牌，我有罪。

专业课
- 地铁上看了两节线代
    - 向量空间，子空间，矩阵的列空间，零空间

算法题
- 49 字母异位词分组，很水，排序
- 538 把二叉搜索树转换为累加树，也很简单，但是我做笨了，没用好搜索树的条件，实际倒序中序遍历就可以了

## 4月10日

项目复盘：
- hook 模块的通用方法 `do_io` 的实现：
    - 先进行一些基本判断，如果是禁用 hook 、 fd 本身就是阻塞等情况下，直接调用未被 hook 的对应方法，然后直接返回
    - 否则，也是直接调用未被 hook 的对应方法，但是有一些后续的步骤
    - 首先，如果对应方法直接调用成功，则正常返回
    - 否则如果错误是 `EAGAIN` ，需要重新尝试。这时需要查看此 fd 上有没有设置 `to` ，即超时等待间隔
        - 简单的情况是没有 `to`，如果是这样，那么直接在该 fd 上添加对应的事件，这个时间的回调就是当前协程，然后协程 yield 出去即可。将来有可处理的数据到来时候，当前协程会从 yield 出去的地方回来继续执行，即 `go to retry`，然后正常处理 io ，然后返回。如果再次处理失败，就重复这一流程
        - 包含 `to` 的情况比较复杂。因为经过 `to` 时间以后，无论该 io 函数是否被 epoll 唤醒，都要再次尝试执行。那么首先需要新增一个 `Timer` ，其触发时间就是 `to` ，但是这个 `Timer` 的回调需要仔细考虑。
        这种情况下，当前 io 操作再次执行的可能性有两种，一是数据准备好后被 epoll 唤醒，二是定时器超时。这里的处理方法是：epoll 唤醒的情况下，处理方式跟前面一样。但是对于超时定时器，这是一个 conditional timer ，其回调触发的条件是当前 io 函数里的一个局部变量 `tinfo`，如果 epoll 唤醒并正常结束，则当前 io 协程结束，`tinfo` 被释放，conditional timer 自然不会触发，并且当前协程结束时也会主动关闭这个 timer。而如果发生超时，则 `tinfo` 仍在内存中，timer 回调正常触发，timer 回调中会把 `tinfo` 标记为超时，并 `cancel_event` 直接尝试调度当前事件的回调，即使 epoll 没有数据到来的通知。定时器触发后，如果有数据到来，协程被 epoll 唤醒，则协程首先检查 `tinfo` ，如果 `tinfo` 没被标记为超时，那就万事大吉，正常进行 io ，如果已经被标记为超时，说明数据来晚了，所以啥也不做直接返回 -1。

- `EPOLLET` 和 `EPOLLLT`
    - ET 的 E 即为 edge ，表示边沿触发，即状态发生变化时，`epoll_wait` 才返回

算法题
    - 每日一题 1019. 链表中的下一个更大节点，单调栈裸题

## 4月11日

项目复盘：
- 关于 ucontext.h

专业课：
- 线性代数：
m×n 秩为 r 的矩阵 A 从行的角度来说表达一个 n 维空间里的 r 维子空间，从列来说表达一个 m 维空间里的 r 维子空间，所以 r <= min(m, n)，
且都是 A 表示的子空间，从哪个角度来看待并不会改变这个子空间的维度，所以行秩等于列秩序，A^T 相当于交换了 m 维空间和 n 维空间的地位，不改变这个 r 维子空间，所以 r(A^T) = r(A) 。
A 右乘一个 n 维向量就是把这个 n 维空间中的向量映射到 m 维空间里由 A 表示的 r 维子空间上去，这个过程中一定有 n-r 个维度上的所有向量被压缩到 0 ，所以 A 的零空间秩等于 n-r。
进而讨论 Ax=b 时自然分以下情况：
1. 如果 r = n < m ，相当于把低维空间向量往高维空间映射，那么只有像恰好在高维空间的这个低位子空间内时，才有唯一解，其他时候都无解。
2. 如果 r = m < n，相当于把高维空间向量往低维空间映射，一定有无穷多解
3. 如果 r < min(m, n)，这时 Ax=b 相当于 n 维原像和 m 维的像在 r 维子空间上的投影恰好相同，所以要么无解要么无穷多解（特解 + 整个 A 的零空间）

算法题
- 每日一题是个机器人转圈，模拟，做的比较笨了

## 4月12日

项目复盘

其实今天没看，但是昨天写得太笼统了，稍微细写一下：
- 还是关于协程的实现，有关 ucontext.h 的部分
  - 线程是隶属于进程的，所以一个进程的所有线程共享这个进程的地址空间，线程的栈、数据等也都在进程的地址空间内
  - 系统级的线程实际上是由操作系统在进程的地址空间内分配空间给线程，由操作系统维护其各种属性
  - ucontext 库所做的工作实际上是在用户态从进程地址空间内分配内存作为栈，来实现用户态的线程，也就是协程

专业课
- 线性代数
今天需要对昨天写的日志里的一些想法做一些修正。昨天那部分内容为了便于理解，把秩为 r 的矩阵视为了一个空间，借助这个空间建立行空间和列空间的联系，感觉这样还是不太准确的。
首先不应该再纠结行空间和列空间的关联了，就像我们说一个从 X 到 Y 的映射 f 的时候不会问 X 和 Y 有什么关系一样。矩阵就是这个 f ，R^n 空间就是 X ，R^m 空间就是 Y， m × n 秩为 r 的矩阵 A 只是一种 X 到 Y 的映射。
A 的行空间和零空间加起来形成了 X ，列空间和左零空间加起来形成了 Y ，所以自然 N(A) = n - r。

关于行秩与列秩为什么相等：
>向量组的秩就象‘自由度’，如果在一组基上，比如三个三维的向量，自由度是3，仅在已有的基上添加一个分量，变成三个四维的向量，那是无法增加‘自由度’的，自由度还是3。要增加一个自由度，必须新增一个四维向量，第四个分量上不为0，这样才能产生4个‘自由度’。这个过程可以看成：行向量与列向量上都同时增加了自由度。所以，行秩与列秩必相等。

至于讨论 Ax = b 的解的情况问题，只从高斯消元的角度来看就已经很好理解了：
1. r = m < n ，是一个矮胖矩阵，消元以后不会有 0 行，肯定无数组解
2. r = n < m ，是一个高瘦矩阵，消元以后有 0 行，所以不一定有解，视 b 的脸色而定，如果有解，那也是唯一解
3. r < min(m, n) ，消元以后下面有 0 行，上面主元也没填满所有列，所以先看 b 脸色确定有没有解，可能无解，而一旦有解，就可以利用自由元构造无数组解


算法题
- 前缀和 + 哈希表的应用

## 4月13日

专业课
- 常见的进程调度算法
  - 先来先服务
  - 优先级调度（抢占和非抢占）
  - 时间片轮转
  - 小进程优先
  - 剩余时间短优先
  - 最高响应比优先（挂起时间长的先执行）
  - 多级反馈队列

- 常见内存替换算法
  - 最佳置换 OPT （无法实现，用来作为 benchmark）
  - 先进先出 FIFO
  - 最近最久未使用 LRU
  - 时钟页面置换 Lock
  - 最不常用置换 LFU

- Cache 替换算法
和内存替换很像，主要是 LRU，LFU，FIFO，随机

算法题
链表检测环 + O(n) 时间检测数字 0~n 中每个数的二进制里 1 的个数，动态规划

## 4月14日

做了 ios 开发的期中作业，无进度

## 4月15日

专业课
- 线性代数
    - 实际中问题经常有为了测量一组参数而进行多次试验的情况，为了准确，试验的次数常常远超参数的个数，也就得到远超未知数个数的线性方程，这时按照 Ax = b 来求解参数 x 的话，大概率是无解的。
    这种情况下，我们通常希望的不是 Ax = b 有解，而是希望求出一个“最接近能使 Ax=b 成立”的 x。
    分析这一问题，x 是 rowspace(A) 中的向量（这里认为 A 是列满秩的，即 r(A) = N ，所以 N(A) = 0，即 rowspace(A) 就是整个 n 维空间），Ax 把 x 映射到 colspace(A) 中，然而 b 不一定在 colspace(中)，导致问题无解。那么要找到“最接近使方程成立”的 x ，我们就求出 colspace(A) 中最接近 b 的向量 p ，把问题转换为求解 Ax = p，这就一定有解了。这里的 p 就是 b 在 colspace(A) 上的投影。
    如何求解这个 p 呢？关键在于 p 是 b 的投影，那么 p 距离 b 的误差 e = b - p 一定垂直于 colspace(A)，那么 A^T(b - p) = 0，又有 p 在 colspace(A) 中，那么 p = Ax'，所以 A^T Ax' = A^t b，这就是“最接近能使 Ax=b 成立”的 x。

- 操作系统
    - 静态链接：根据 call 指令的语义，回填一个函数的地址时需要计算出目标函数入口地址距离当前 call 的距离，即所谓“S + A - P”，即 S - (P - A)，P - A 就是当前 pc，S - 当前 pc 就得到了这个相对寻址的偏移量
    - 追踪系统调用的方式：strace，strace 通过 ptrace 系统调用实现，被 ptrace 追踪的进程收到的信号会转发给父进程，然后子进程阻塞，然后父进程可以对子进程进行一些操作。gdb 的实现就是基于这一点，把断点处的指令替换为 TRAP 指令