---
title: 用 C/C++ 写一个自己的 Redis
date: 2023-07-23 21:27:36
tags:
    - C++
    - C
    - Redis
categories: C/C++
keywords: 'Build your own, C/C++, Redis'
description: 从 0 用 C/C++ 自己写一个 Redis
cover: cover.png
---

原文链接：https://build-your-own.org/redis/
翻译：伊织

**从 0 开始写代码来学习网络编程和数据结构**

作者：James Smith

- **为什么要写 Redis ？** 因为写一个 Redis 所需要的知识比一般的应用层开发来得更广也更深，这是一种很好的培养能力的办法。（主要是在网络编程和数据结构方面）
- **为什么从 0 开始写？** Richard Feynman 有句名言：“只要我不能创造的，我就还不理解”。人类的理解充满了漏洞，即“我不知道我不知道的事情”。从 0 开始编程能够确保你的理解比较完整。
- **为什么要写 C ？** 因为 C 语言被广泛应用在系统编程和基础软件中，所以通过直接的 C 代码来学习 C 是如何在实际项目中应用的，而且也不需要 C/C++ 的预备知识。
- **为什么是以一本书的形式？** Redis 非常复杂，花费了人们很多精力，初学者直接学习会非常困难。这本书把核心的概念拆开，以便读者学习。

# 介绍

## 这本书是写什么的？

这本书一步一步地演示了一个 Redis-like 的 server 的简单实现，旨在成为一个 C 语言网络编程和数据结构的实现与应用的使用指南/教程。

## 从这本书能学到什么？

Redis 可以被认为是现代计算机世界的*一块基石*，经受住了时间的考验。编写这样一个项目所需的知识比通常的应用层开发来得更广也更深。学习这样一个项目是程序员自我提高的一种非常好的办法。
Redis 是一个非常好的学习目标，因为它涵盖了软件工程的两个重要主题：网络编程和数据结构。

- 你能找到很多 socket API 和高级程序库的教程，但是网络编程远远不止调包这么简单。很重要的一点是要理解一些核心概念，比如事件循环（event loop）、协议（protocol）、定时器（timer）等等，这本书里都会包含。如果你不理解这些核心概念，那你就算只当调包侠，也常常会写出 fatal error。
- 很多人从书上学会了基本数据结构，但其实要继续学的东西还多着呢。真实项目中的数据结构往往有一些教科书上不会提及的实践考量。学习一个非玩具的正经项目中是怎么使用数据结构的，这会是写 Redis 带给你的一段独特体验。

正如大多数真实世界的项目一样，Redis 非常复杂，凝结了人们大量的努力，对于初学者来说直接学习会非常困难。因此这本书采取一种相反的策略：*从零开始*自己写一个。

## 为什么要从 0 开始？

原因有以下几点：

- **为了学得更快。** 从 0 开始写一样东西的过程能够循序渐进的引入各个概念。从最小的东西开始，增量地添加功能，最后搞个大的出来。
- **为了学得更深。** 虽然有很多资料可以解释现在的东西都是怎么工作的，但你从阅读资料中获得的理解通常不如自己写一个来得深刻。只读不写的话就很容易记错，或者找不到重点。
- **为了学得更多。** “从 0 开始”强迫你去了解项目的各个方面，不会有你错过的知识！而且通常不是每个方面的知识你都提前有所了解的，你会在这个过程中发现一些“我不知道我不知道的东西”。

一言以蔽之，就是 Richard Feynman 的名言：“只要我不能创造的，我就还不理解”。

## 如何使用本书？

这本书之后的章节会是循序渐进一步一步的。每一步都基于上一步，增加一个新的概念。网站会提供完整的源代码，建议读者自行调试或者尝试自己编写。

作者会把代码写得尽可能直截了当。大多数是朴素的 C 语言，少部分涉及 C++ 特性。没学过 C 的话也别担心，你刚好可以自己用另一门语言来实现。

最后的成果会是一个迷你版的 Redis ，差不多就 1200 行代码。别看 1200 很少，其中包括了这本书覆盖的很多重要方面。

这本书中使用的技术和方法并不是和真实的 Redis 完全一致的，有一部分可以简化了，有一些更普适化。比较这些方法的不同点能让读者学到更多东西。

这本书的代码只能在 Linux 上跑，可以从这里下载：

https://build-your-own.org/redis/src.tgz

书的内容和源代码可以在这里在线阅读：

https://build-your-own.org


# Socket 简介

这一章是 socket 编程介绍。读者应该有基本的计算机网络知识，但不是必须有网络编程经验。本书不会包含 socket API 的细节，建议读者学习本书的同时去阅读 API 手册和其他网络编程教程。(推荐一个学习 socket API 的材料： https://beej.us/)

Redis 是一个 server/client 系统。多个客户端连接到一个服务器，服务器从 TCP 连接上收到请求，并发回响应。在开始 socket 编程之前，先要学习几个 Linux 系统调用。

`socket()` 系统调用返回一个 fd 。如果你不熟悉 Unix 操作系统的话，我粗略地解释一下“fd”：一个 fd 就是一个整数，只想 Linux 内核中的某个对象，比如一个 TCP 连接，一个磁盘上的文件，一个监听端口，或者其他资源等。

`bind()` 和 `listen()`系统调用：`bind()` 将一个地址关联到一个 socket fd 上，`listen()` 使得我们能够接受到这个地址上的连接。

`accept` 接收一个监听 fd 。当一个客户端连接到了监听地址上，`accept` 会返回一个 fd ，代表这个连接。下面是一段解释一般服务器工作流程的伪代码：

```
fd = socket()
bind(fd, address)
listen(fd)
while True:
    conn_fd = accept(fd)
    do_something_with(conn_fd)
    close(conn_fd)
```

`read()` 系统调用会从 TCP 连接上接收数据，`write()` 系统调用则发送数据。`close()` 系统调用会销毁 fd 指向的内核资源，并回收这个 fd 。

我们介绍完了服务端网络编程所需要的系统调用。对于客户端而言，`connect()` 系统调用接受一个 socket fd 和一个地址，并向这个地址发起一个 TCP 连接。下面是客户端的伪代码：

```
fd = socket()
connect(fd, address)
do_something_with(fd)
close(fd)
```

下一章开始就会使用真正的代码了。

未完待续。